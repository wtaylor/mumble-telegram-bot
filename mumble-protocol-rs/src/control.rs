//! Control channel messages and codecs

use std::convert::TryFrom;
use std::convert::TryInto;
use std::io;
use std::io::Cursor;

use bytes::Buf;
use bytes::BufMut;
use bytes::Bytes;
use bytes::BytesMut;
use prost::{Message};

/// ProtoBuf message types for all Mumble messages.
#[allow(renamed_and_removed_lints)] // protobuf is missing `clippy::` prefix
#[allow(missing_docs)] // these would have to be auto-generated by protobuf
pub mod protobuf {
    /// Mumble message type to packet ID mappings.
    pub mod id {
        pub use super::super::generated_id::*;
    }

    include!(concat!(env!("OUT_DIR"), "/mumble_proto.rs"));
}

/// Raw/not-yet-parsed Mumble control packet.
#[derive(Clone, Debug, PartialEq)]
pub struct RawControlPacket {
    /// Packet ID
    ///
    /// See [protobuf::id].
    pub id: u16,
    /// Raw message bytes.
    pub bytes: Bytes,
}

/// A `Codec` implementation that parses a stream of data into [RawControlPacket]s.
#[derive(Debug)]
pub struct RawControlCodec;

impl RawControlCodec {
    /// Creates a new RawControlCodec.
    pub fn new() -> Self {
        Default::default()
    }
}

impl Default for RawControlCodec {
    fn default() -> Self {
        RawControlCodec
    }
}

impl RawControlCodec {
    fn encode(&mut self, item: RawControlPacket, dst: &mut BytesMut) -> Result<(), io::Error> {
        let id = item.id;
        let bytes = &item.bytes;
        let len = bytes.len();
        dst.reserve(6 + len);
        dst.put_u16(id);
        dst.put_u32(len as u32);
        dst.put_slice(bytes);
        Ok(())
    }

    fn decode(&mut self, buf: &mut BytesMut) -> Result<Option<RawControlPacket>, io::Error> {
        let buf_len = buf.len();
        if buf_len >= 6 {
            let mut buf = Cursor::new(buf);
            let id = buf.get_u16();
            let len = buf.get_u32() as usize;
            if len > 0x7f_ffff {
                Err(io::Error::new(io::ErrorKind::Other, "packet too long"))
            } else if buf_len >= 6 + len {
                let mut bytes = buf.into_inner().split_to(6 + len);
                bytes.advance(6);
                let bytes = bytes.freeze();
                Ok(Some(RawControlPacket { id, bytes }))
            } else {
                Ok(None)
            }
        } else {
            Ok(None)
        }
    }
}

impl tokio_util::codec::Decoder for RawControlCodec {
    type Item = RawControlPacket;
    type Error = io::Error;

    fn decode(&mut self, src: &mut BytesMut) -> Result<Option<Self::Item>, Self::Error> {
        self.decode(src)
    }
}

impl tokio_util::codec::Encoder<RawControlPacket> for RawControlCodec {
    type Error = io::Error;

    fn encode(&mut self, item: RawControlPacket, dst: &mut BytesMut) -> Result<(), io::Error> {
        self.encode(item, dst)
    }
}

/// A `Codec` implementation that parses a stream of data into [ControlPacket]s.
#[derive(Debug)]
pub struct ControlCodec {
    inner: RawControlCodec
}

pub type ClientControlCodec = ControlCodec;

impl ControlCodec {
    /// Creates a new control codec.
    pub fn new() -> Self {
        Default::default()
    }
}

impl Default for ControlCodec
{
    fn default() -> Self {
        ControlCodec {
            inner: RawControlCodec::default()
        }
    }
}

impl ControlCodec {
    fn decode(
        &mut self,
        src: &mut BytesMut,
    ) -> Result<Option<ControlPacket>, io::Error> {
        Ok(if let Some(raw_packet) = self.inner.decode(src)? {
            Some(raw_packet.try_into()?)
        } else {
            None
        })
    }
}

impl tokio_util::codec::Decoder for ControlCodec
{
    type Item = ControlPacket;
    type Error = io::Error;

    fn decode(&mut self, src: &mut BytesMut) -> Result<Option<Self::Item>, Self::Error> {
        self.decode(src)
    }
}

impl tokio_util::codec::Encoder<ControlPacket> for ControlCodec
{
    type Error = io::Error;

    fn encode(
        &mut self,
        item: ControlPacket,
        dst: &mut BytesMut,
    ) -> Result<(), Self::Error> {
        self.inner.encode(item.into(), dst)
    }
}

/// Generates packet to ID mappings which will end up in [protobuf::ids].
macro_rules! define_packet_mappings {
    ( @def $id:expr, $name:ident) => {
        #[allow(dead_code)]
        #[allow(non_upper_case_globals)]
        pub const $name: u16 = $id;
    };
    ( @rec $id:expr, $(#[$attr:meta])* $head:ident ) => {
        $(#[$attr])*
        define_packet_mappings!(@def $id, $head);
    };
    ( @rec $id:expr, $(#[$attr:meta])* $head:ident, $( $(#[$attr_tail:meta])* $tail:ident ),* ) => {
        $(#[$attr])*
        define_packet_mappings!(@def $id, $head);
        define_packet_mappings!(@rec $id + 1, $($(#[$attr_tail])* $tail),*);
    };
    ( $( $(#[$attrs:meta])* $names:ident ),* ) => {
        define_packet_mappings!(@rec 0, $($(#[$attrs])* $names),*);
    };
}

/// Generates From impls for converting between RawCtrlPck <=> ProtoMsg => CtrlPck
macro_rules! define_packet_from {
    ( $Dst:ident $name:ident($type:ty) ) => {
        impl From<$type> for ControlPacket {
            fn from(inner: $type) -> Self {
                ControlPacket::$name(Box::new(inner))
            }
        }
        impl From<$type> for RawControlPacket {
            fn from(msg: $type) -> Self {
                Self {
                    id: self::protobuf::id::$name,
                    bytes: msg.encode_to_vec().into()
                }
            }
        }
        impl TryFrom<RawControlPacket> for $type {
            type Error = io::Error;

            fn try_from(packet: RawControlPacket) -> Result<Self, Self::Error> {
                if packet.id == protobuf::id::$name {
                    Self::try_from(packet.bytes)
                } else {
                    Err(io::Error::new(io::ErrorKind::Other, concat!("expected packet of type ", stringify!($name))))
                }
            }
        }
        impl TryFrom<&[u8]> for $type {
            type Error = io::Error;

            fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
                Ok(Self::decode(bytes)?)
            }
        }
        impl TryFrom<Bytes> for $type {
            type Error = io::Error;

            fn try_from(bytes: Bytes) -> Result<Self, Self::Error> {
                bytes.as_ref().try_into()
            }
        }
    };
}

/// Generates the ControlPacket enum, From impls for RawCtrlPck <=> CtrlPck and CtrlPck::name()
macro_rules! define_packet_enum {
    ( $Dst:ident $( $(#[$attr:meta])* $name:ident($type:ty) ),* ) => {
        /// A parsed Mumble control packet.
        #[derive(Debug, Clone, PartialEq)]
        #[allow(clippy::large_enum_variant)]
        #[non_exhaustive]
        pub enum ControlPacket {
            $(
                #[allow(missing_docs)]
                $(#[$attr])*
                $name(Box<$type>),
            )*
            /// A packet of unknown type.
            Other(RawControlPacket),
        }
        impl TryFrom<RawControlPacket> for ControlPacket {
            type Error = io::Error;

            fn try_from(packet: RawControlPacket) -> Result<Self, Self::Error> {
                Ok(match packet.id {
                    $(
                        $(#[$attr])*
                        protobuf::id::$name => {
                            ControlPacket::$name(Box::new(packet.bytes.try_into()?))
                        }
                    )*
                        _ => ControlPacket::Other(packet),
                })
            }
        }
        impl From<ControlPacket> for RawControlPacket {
            fn from(packet: ControlPacket) -> Self {
                match packet {
                    $(
                        $(#[$attr])*
                        ControlPacket::$name(inner) => (*inner).into(),
                    )*
                        ControlPacket::Other(inner) => inner,
                }
            }
        }
        impl ControlPacket {
            /// Returns the internal name of a packet (for debugging purposes).
            pub fn name(&self) -> &'static str {
                match self {
                    $(
                        $(#[$attr])*
                        ControlPacket::$name(_) => stringify!($name),
                    )*
                    ControlPacket::Other(_) => "unknown",
                }
            }
        }
    };
}

macro_rules! define_packets {
    ( < $Dst:ident > $( $(#[$attr:meta])* $name:ident($type:ty), )* ) => {
        #[allow(missing_docs)]
        mod generated_id {
            define_packet_mappings!($($(#[$attr])* $name),*);
        }
        define_packet_enum!($Dst $($(#[$attr])* $name($type)),*);
        $(
            $(#[$attr])*
            define_packet_from!($Dst $name($type));
        )*
    };
}

define_packets![
    <Dst>
    Version(protobuf::Version),
    UdpTunnel(protobuf::UdpTunnel),
    Authenticate(protobuf::Authenticate),
    Ping(protobuf::Ping),
    Reject(protobuf::Reject),
    ServerSync(protobuf::ServerSync),
    ChannelRemove(protobuf::ChannelRemove),
    ChannelState(protobuf::ChannelState),
    UserRemove(protobuf::UserRemove),
    UserState(protobuf::UserState),
    BanList(protobuf::BanList),
    TextMessage(protobuf::TextMessage),
    PermissionDenied(protobuf::PermissionDenied),
    ACL(protobuf::Acl),
    QueryUsers(protobuf::QueryUsers),
    CryptSetup(protobuf::CryptSetup),
    ContextActionModify(protobuf::ContextActionModify),
    ContextAction(protobuf::ContextAction),
    UserList(protobuf::UserList),
    VoiceTarget(protobuf::VoiceTarget),
    PermissionQuery(protobuf::PermissionQuery),
    CodecVersion(protobuf::CodecVersion),
    UserStats(protobuf::UserStats),
    RequestBlob(protobuf::RequestBlob),
    ServerConfig(protobuf::ServerConfig),
    SuggestConfig(protobuf::SuggestConfig),
    PluginDataTransmission(protobuf::PluginDataTransmission),
];
